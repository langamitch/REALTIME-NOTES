<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Real-Time Dual-Device Notes</title>
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <style>
      /* --- Basic Styling --- */
      :root {
        --primary-color: black;
        --primary-hover: #0056b3;
        --danger-color: #d9534f;
        --success-color: #28a745;
        --warning-color: #ffc107;
        --light-gray: #484848;
        --border-color: #000000;
        --background-color: #000000;
        --text-color: #ffffff;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        background-color: black;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        color: var(--text-color);
      }
      .container {
        background: var(--background-color);
        padding: 1rem;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        width: 90%;
        max-width: 700px;
        text-align: center;
      }
      .hidden {
        display: none !important;
      }
      h2,
      h3 {
        margin-top: 0;
      }
      h2 {
        font-size: 16px;
        margin-bottom: 20px;
      }
      textarea,
      #viewer-content {
        width: 100%;
        background-color: #000000;
        color: #fafafa;
        height: 400px;
        box-sizing: border-box;
        font-size: 1rem;
        padding: 10px;
        border: 1px solid white;
        border-radius: 4px;
        resize: vertical;
      }
      #viewer-content {
        background: #fafafa;
        overflow-y: auto;
        white-space: pre-wrap; /* Respects newlines */
        text-align: left;
      }
      button {
        padding: 5px 15px;
        border: none;
        background-color: var(--primary-color);
        color: white;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 20px;
        border: 2px solid white;
        font-size: 13px;
        font-weight: 500;
        transition: background-color 0.2s;
      }
      button:hover {
        background-color: var(--primary-hover);
      }
      .role-prompt button {
        width: 120px;
        height: 120px;
        font-size: 1.2rem;
        margin: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }
      #auth-screen input {
        display: block;
        background-color: #000000;
        width: calc(80% - 22px);
        padding: 8px;
        color: #ffffff;
        font-size: 16px;
        margin: 0 auto 10px auto;
        border: 2px solid white;
        border-radius: 4px;
      }
      #logout-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        background-color: var(--danger-color);
      }
      #status-bar {
        margin-top: 20px;
        padding-top: 15px;
        border-top: 1px solid #eee;
        font-size: 0.9rem;
        color: #555;
        line-height: 1.4;
      }
      .connection-status {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 8px;
      }
      .status-connected {
        background-color: var(--success-color);
      }
      .status-connecting {
        background-color: var(--warning-color);
      }
      .status-disconnected {
        background-color: var(--danger-color);
      }
      .device-list {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 10px;
        margin: 10px 0;
        text-align: left;
      }
      .device-item {
        padding: 5px 0;
        border-bottom: 1px solid #eee;
      }
      .device-item:last-child {
        border-bottom: none;
      }
      .typer-indicator {
        color: var(--success-color);
        font-weight: bold;
      }
      .connection-status {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 8px;
      }
      .status-connected {
        background-color: var(--success-color);
      }
      .status-connecting {
        background-color: var(--warning-color);
      }
      .status-disconnected {
        background-color: var(--danger-color);
      }
      .device-list {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 10px;
        margin: 10px 0;
        text-align: left;
      }
      .device-item {
        padding: 5px 0;
        border-bottom: 1px solid #eee;
      }
      .device-item:last-child {
        border-bottom: none;
      }
      .typer-indicator {
        color: var(--success-color);
        font-weight: bold;
      }

      /* Role switching styles */
      .role-switcher {
        position: relative;
        display: inline-block;
        margin: 10px 0;
      }

      .role-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        background: var(--background-color);
        border: 2px solid white;
        border-radius: 4px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        min-width: 150px;
        display: none;
      }

      .role-dropdown.show {
        display: block;
      }

      .role-option {
        padding: 10px 15px;
        cursor: pointer;
        border-bottom: 1px solid #333;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .role-option:hover {
        background-color: var(--light-gray);
      }

      .role-option:last-child {
        border-bottom: none;
      }

      .role-option.active {
        background-color: var(--primary-color);
        color: white;
      }

      /* Multitasking mode styles */
      .multitask-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 20px;
      }

      .multitask-panel {
        border: 1px solid white;
        border-radius: 4px;
        padding: 10px;
      }

      .multitask-panel h4 {
        margin: 0 0 10px 0;
        font-size: 14px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 5px;
      }

      .multitask-textarea {
        width: 100%;
        background-color: #000000;
        color: #fafafa;
        height: 300px;
        box-sizing: border-box;
        font-size: 0.9rem;
        padding: 8px;
        border: 1px solid white;
        border-radius: 4px;
        resize: vertical;
      }

      /* Document history styles */
      .history-container {
        margin-top: 20px;
        border: 1px solid white;
        border-radius: 4px;
        padding: 15px;
      }

      .history-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 15px;
      }

      .history-list {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #333;
        border-radius: 4px;
        background: #111;
      }

      .history-item {
        padding: 10px;
        border-bottom: 1px solid #333;
        cursor: pointer;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .history-item:hover {
        background-color: var(--light-gray);
      }

      .history-item:last-child {
        border-bottom: none;
      }

      .history-item.active {
        background-color: var(--primary-color);
        color: white;
      }

      .history-info {
        flex: 1;
      }

      .history-title {
        font-weight: bold;
        margin-bottom: 5px;
      }

      .history-meta {
        font-size: 0.8rem;
        color: #aaa;
      }

      .history-actions {
        display: flex;
        gap: 5px;
      }

      .history-btn {
        padding: 3px 8px;
        font-size: 0.7rem;
        margin: 0;
      }

      .history-preview {
        margin-top: 15px;
        padding: 10px;
        background: #111;
        border: 1px solid #333;
        border-radius: 4px;
        max-height: 200px;
        overflow-y: auto;
        white-space: pre-wrap;
        font-size: 0.9rem;
      }

      .no-history {
        text-align: center;
        color: #666;
        padding: 20px;
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div id="auth-screen">
        <h2>Dual-Device Notes Login</h2>
        <input type="email" id="email" placeholder="Email" />
        <input type="password" id="password" placeholder="Password" />
        <button id="login-btn">Login</button>
        <button id="signup-btn">Sign Up</button>
      </div>

      <div id="app-screen" class="hidden">
        <button id="logout-btn">Logout</button>
        <h2>Live Note</h2>

        <div id="role-prompt" class="hidden">
          <h3>Multiple Devices Detected!</h3>
          <p>Choose a role for this device.</p>
          <button id="typer-btn">
            <span class="material-icons">edit</span> Typer
          </button>
          <button id="viewer-btn">
            <span class="material-icons">visibility</span> Viewer
          </button>
        </div>

        <div id="typer-mode" class="hidden">
          <h3>Typer Mode</h3>
          <div class="role-switcher">
            <button id="role-switch-btn">
              <span class="material-icons">expand_more</span> Switch Role
            </button>
            <div id="role-dropdown" class="role-dropdown">
              <div class="role-option" data-role="viewer">
                <span class="material-icons">visibility</span> Switch to Viewer
              </div>
              <div class="role-option" data-role="multitask">
                <span class="material-icons">sync</span> Multitask Mode
              </div>
            </div>
          </div>
          <textarea
            id="note-editor"
            placeholder="Start typing... changes are saved and synced in real-time."
          ></textarea>
        </div>

        <div id="viewer-mode" class="hidden">
          <h3>Viewer Mode (Read-only)</h3>
          <div class="role-switcher">
            <button id="role-switch-btn">
              <span class="material-icons">expand_more</span> Switch Role
            </button>
            <div id="role-dropdown" class="role-dropdown">
              <div class="role-option" data-role="typer">
                <span class="material-icons">edit</span> Switch to Typer
              </div>
              <div class="role-option" data-role="multitask">
                <span class="material-icons">sync</span> Multitask Mode
              </div>
            </div>
          </div>
          <div id="viewer-content">Waiting for content...</div>
        </div>

        <div id="multitask-mode" class="hidden">
          <h3>Multitask Mode</h3>
          <div class="role-switcher">
            <button id="role-switch-btn">
              <span class="material-icons">expand_more</span> Switch Role
            </button>
            <div id="role-dropdown" class="role-dropdown">
              <div class="role-option" data-role="typer">
                <span class="material-icons">edit</span> Switch to Typer
              </div>
              <div class="role-option" data-role="viewer">
                <span class="material-icons">visibility</span> Switch to Viewer
              </div>
            </div>
          </div>
          <div class="multitask-container">
            <div class="multitask-panel">
              <h4><span class="material-icons">edit</span> Editor Panel</h4>
              <textarea
                id="multitask-editor"
                class="multitask-textarea"
                placeholder="Type here... changes sync to viewer panel."
              ></textarea>
            </div>
            <div class="multitask-panel">
              <h4>
                <span class="material-icons">visibility</span> Viewer Panel
              </h4>
              <div id="multitask-viewer" class="multitask-textarea">
                Waiting for content...
              </div>
            </div>
          </div>
        </div>

        <div id="status-bar">Connecting...</div>

        <!-- Document History Section -->
        <div class="history-container">
          <div class="history-header">
            <h3>
              <span class="material-icons">history</span> Document History
            </h3>
            <button id="refresh-history-btn" class="history-btn">
              <span class="material-icons">refresh</span> Refresh
            </button>
          </div>
          <div id="history-list" class="history-list">
            <div class="no-history">Loading document history...</div>
          </div>
          <div id="history-preview" class="history-preview hidden">
            <div class="history-header">
              <h4>Document Preview</h4>
              <button id="restore-doc-btn" class="history-btn">
                <span class="material-icons">restore</span> Restore
              </button>
            </div>
            <div id="preview-content"></div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <script>
      // =================================================================
      // ðŸ”¥ PASTE YOUR FIREBASE CONFIGURATION OBJECT HERE
      // =================================================================
      const firebaseConfig = {
        apiKey: "AIzaSyC77ot4Lmu3q10fkNRSQTnTa_eSpTywloo",
        authDomain: "realtime-note-720c7.firebaseapp.com",
        projectId: "realtime-note-720c7",
        storageBucket: "realtime-note-720c7.firebasestorage.app",
        messagingSenderId: "904825696682",
        appId: "1:904825696682:web:e449475c3abfb2a95d3bd3",
        measurementId: "G-SJGKQSDQGL",
      };

      // =================================================================
      // ðŸš€ APP INITIALIZATION
      // =================================================================
      firebase.initializeApp(firebaseConfig);
      const auth = firebase.auth();
      const db = firebase.firestore();

      // --- Global State & Refs ---
      let currentUser = null;
      let activeDevicesListener = null;
      let noteListener = null;
      let deviceIP = null;
      let heartbeatInterval = null;
      let documentHistory = [];
      let selectedHistoryDoc = null;
      const NOTE_ID = "shared_note"; // Using one shared note for this example

      // --- UI Elements ---
      const authScreen = document.getElementById("auth-screen");
      const appScreen = document.getElementById("app-screen");
      const rolePrompt = document.getElementById("role-prompt");
      const typerMode = document.getElementById("typer-mode");
      const viewerMode = document.getElementById("viewer-mode");
      const multitaskMode = document.getElementById("multitask-mode");
      const noteEditor = document.getElementById("note-editor");
      const viewerContent = document.getElementById("viewer-content");
      const multitaskEditor = document.getElementById("multitask-editor");
      const multitaskViewer = document.getElementById("multitask-viewer");
      const statusBar = document.getElementById("status-bar");
      const historyList = document.getElementById("history-list");
      const historyPreview = document.getElementById("history-preview");
      const previewContent = document.getElementById("preview-content");

      // =================================================================
      // ðŸŒ IP ADDRESS DETECTION
      // =================================================================
      async function getDeviceIP() {
        try {
          // Try to get IP from a public service
          const response = await fetch("https://api.ipify.org?format=json");
          const data = await response.json();
          return data.ip;
        } catch (error) {
          console.warn("Could not get public IP, using fallback:", error);
          // Fallback: generate a pseudo-IP based on timestamp and random number
          return `192.168.1.${Math.floor(Math.random() * 254) + 1}`;
        }
      }

      // =================================================================
      // ðŸ‘¤ AUTHENTICATION LOGIC
      // =================================================================
      document.getElementById("login-btn").addEventListener("click", () => {
        const email = document.getElementById("email").value;
        const password = document.getElementById("password").value;
        if (!email || !password) {
          alert("Please enter both email and password");
          return;
        }
        auth
          .signInWithEmailAndPassword(email, password)
          .catch((error) => alert(error.message));
      });

      document.getElementById("signup-btn").addEventListener("click", () => {
        const email = document.getElementById("email").value;
        const password = document.getElementById("password").value;
        if (!email || !password) {
          alert("Please enter both email and password");
          return;
        }
        auth
          .createUserWithEmailAndPassword(email, password)
          .catch((error) => alert(error.message));
      });

      document.getElementById("logout-btn").addEventListener("click", () => {
        auth.signOut();
      });

      // The main observer for auth state
      auth.onAuthStateChanged(async (user) => {
        if (user) {
          // User is signed in
          currentUser = user;
          authScreen.classList.add("hidden");
          appScreen.classList.remove("hidden");

          // Get device IP before registering
          deviceIP = await getDeviceIP();
          await registerDevice();
          listenForDeviceChanges();
          listenForNoteChanges();
          startHeartbeat();
          setupRoleSwitching(); // Initialize role switching functionality
          loadDocumentHistory(); // Load document history
          startHistoryAutoSave(); // Start auto-save to history
        } else {
          // User is signed out
          await cleanup();
          currentUser = null;
          deviceIP = null;
          authScreen.classList.remove("hidden");
          appScreen.classList.add("hidden");
        }
      });

      // =================================================================
      // ðŸ’» DEVICE & SESSION MANAGEMENT
      // =================================================================
      async function registerDevice() {
        if (!currentUser || !deviceIP) return;
        const deviceRef = db
          .collection("users")
          .doc(currentUser.uid)
          .collection("activeDevices")
          .doc(deviceIP);
        try {
          await deviceRef.set({
            ipAddress: deviceIP,
            lastActive: firebase.firestore.FieldValue.serverTimestamp(),
            role: "pending", // Role is 'pending' until assigned
            userAgent: navigator.userAgent,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          });
        } catch (error) {
          console.error("Error registering device:", error);
        }
      }

      function startHeartbeat() {
        // Send heartbeat every 30 seconds to keep device active
        heartbeatInterval = setInterval(async () => {
          if (currentUser && deviceIP) {
            const deviceRef = db
              .collection("users")
              .doc(currentUser.uid)
              .collection("activeDevices")
              .doc(deviceIP);
            await deviceRef
              .update({
                lastActive: firebase.firestore.FieldValue.serverTimestamp(),
              })
              .catch((err) => console.error("Heartbeat error:", err));
          }
        }, 30000);
      }

      function listenForDeviceChanges() {
        if (activeDevicesListener) activeDevicesListener(); // Unsubscribe from previous listener

        const devicesRef = db
          .collection("users")
          .doc(currentUser.uid)
          .collection("activeDevices");
        activeDevicesListener = devicesRef.onSnapshot(
          (snapshot) => {
            const devices = snapshot.docs.map((doc) => ({
              id: doc.id,
              ipAddress: doc.id,
              ...doc.data(),
            }));

            // Filter out devices that haven't been active in the last 2 minutes
            const now = Date.now();
            const activeDevices = devices.filter((device) => {
              const lastActive =
                device.lastActive?.toDate?.() ||
                new Date(device.timestamp?.toDate?.() || now);
              return now - lastActive.getTime() < 120000; // 2 minutes
            });

            const typer = activeDevices.find((d) => d.role === "typer");
            const thisDevice = activeDevices.find(
              (d) => d.ipAddress === deviceIP
            );

            updateStatusBar(activeDevices, typer);

            if (activeDevices.length > 1 && !typer) {
              showUI("prompt"); // Multiple devices, no typer yet -> show prompt
            } else if (typer && thisDevice?.ipAddress === typer.ipAddress) {
              // Check if this device is in multitask mode
              if (thisDevice.role === "multitask") {
                showUI("multitask");
              } else {
                showUI("typer"); // This device is the typer
              }
            } else if (typer && thisDevice?.ipAddress !== typer.ipAddress) {
              // Check if this device is in multitask mode
              if (thisDevice.role === "multitask") {
                showUI("multitask");
              } else {
                showUI("viewer"); // Another device is the typer
              }
            } else if (activeDevices.length === 1 && thisDevice) {
              setRole("typer"); // Only one device, becomes typer automatically
            }
          },
          (error) => {
            console.error("Error listening to device changes:", error);
          }
        );
      }

      async function setRole(role) {
        if (!currentUser || !deviceIP) return;
        const deviceRef = db
          .collection("users")
          .doc(currentUser.uid)
          .collection("activeDevices")
          .doc(deviceIP);
        await deviceRef.update({
          role: role,
          lastActive: firebase.firestore.FieldValue.serverTimestamp(),
        });
      }

      document
        .getElementById("typer-btn")
        .addEventListener("click", () => setRole("typer"));
      document
        .getElementById("viewer-btn")
        .addEventListener("click", () => setRole("viewer"));

      // Role switching functionality
      function setupRoleSwitching() {
        const roleSwitchBtns = document.querySelectorAll("#role-switch-btn");
        const roleDropdowns = document.querySelectorAll("#role-dropdown");
        const roleOptions = document.querySelectorAll(".role-option");

        // Toggle dropdown on button click
        roleSwitchBtns.forEach((btn, index) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const dropdown = roleDropdowns[index];
            dropdown.classList.toggle("show");
          });
        });

        // Handle role option clicks
        roleOptions.forEach((option) => {
          option.addEventListener("click", (e) => {
            e.stopPropagation();
            const newRole = option.dataset.role;
            setRole(newRole);

            // Close all dropdowns
            roleDropdowns.forEach((dropdown) => {
              dropdown.classList.remove("show");
            });
          });
        });

        // Close dropdowns when clicking outside
        document.addEventListener("click", () => {
          roleDropdowns.forEach((dropdown) => {
            dropdown.classList.remove("show");
          });
        });
      }

      function showUI(mode) {
        rolePrompt.classList.add("hidden");
        typerMode.classList.add("hidden");
        viewerMode.classList.add("hidden");
        multitaskMode.classList.add("hidden");

        if (mode === "prompt") rolePrompt.classList.remove("hidden");
        else if (mode === "typer") typerMode.classList.remove("hidden");
        else if (mode === "viewer") viewerMode.classList.remove("hidden");
        else if (mode === "multitask") multitaskMode.classList.remove("hidden");
      }

      function updateStatusBar(devices, typer) {
        let statusText = `<span class="connection-status status-connected"></span>`;
        statusText += `<b>Your IP:</b> ${deviceIP}<br>`;
        statusText += `<b>Connected Devices:</b> ${devices.length}<br>`;

        if (devices.length > 0) {
          statusText += `<div class="device-list">`;
          devices.forEach((device) => {
            const isTyper = typer && device.ipAddress === typer.ipAddress;
            const isThisDevice = device.ipAddress === deviceIP;
            statusText += `<div class="device-item">`;
            statusText += `<span>${device.ipAddress}</span>`;
            if (isThisDevice)
              statusText += ` <span style="color: var(--primary-color);">(You)</span>`;
            if (isTyper)
              statusText += ` <span class="typer-indicator"><span class="material-icons">edit</span> Typer</span>`;
            else if (device.role === "viewer")
              statusText += ` <span style="color: #666;"><span class="material-icons">visibility</span> Viewer</span>`;
            statusText += `</div>`;
          });
          statusText += `</div>`;
        }

        if (typer) {
          const role =
            typer.ipAddress === deviceIP
              ? "You are the <b>Typer</b>"
              : "You are a <b>Viewer</b>";
          statusText += role;
        } else {
          statusText += "Waiting for a typer to be selected...";
        }
        statusBar.innerHTML = statusText;
      }

      // =================================================================
      // ðŸ“ NOTE SYNCING & CLEANUP
      // =================================================================
      let saveTimeout;

      // Typer: Save to Firestore after user stops typing for 1 second
      noteEditor.addEventListener("input", (e) => {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
          if (!currentUser) return;
          const noteRef = db
            .collection("users")
            .doc(currentUser.uid)
            .collection("notes")
            .doc(NOTE_ID);
          noteRef.set(
            {
              content: e.target.value,
              updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
              updatedBy: deviceIP,
            },
            { merge: true }
          ); // Use merge to avoid overwriting other fields
        }, 1000);
      });

      // Multitask editor: Save to Firestore after user stops typing for 1 second
      multitaskEditor.addEventListener("input", (e) => {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
          if (!currentUser) return;
          const noteRef = db
            .collection("users")
            .doc(currentUser.uid)
            .collection("notes")
            .doc(NOTE_ID);
          noteRef.set(
            {
              content: e.target.value,
              updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
              updatedBy: deviceIP,
            },
            { merge: true }
          ); // Use merge to avoid overwriting other fields
        }, 1000);
      });

      // Viewer/Typer: Listen for note changes from Firestore
      function listenForNoteChanges() {
        if (noteListener) noteListener(); // Unsubscribe

        const noteRef = db
          .collection("users")
          .doc(currentUser.uid)
          .collection("notes")
          .doc(NOTE_ID);
        noteListener = noteRef.onSnapshot(
          (doc) => {
            const content = doc.exists ? doc.data().content : "";
            // Update all views to keep them in sync regardless of role
            if (noteEditor.value !== content) {
              noteEditor.value = content;
            }
            if (viewerContent.textContent !== content) {
              viewerContent.textContent = content;
            }
            if (multitaskEditor.value !== content) {
              multitaskEditor.value = content;
            }
            if (multitaskViewer.textContent !== content) {
              multitaskViewer.textContent = content;
            }
          },
          (error) => {
            console.error("Error listening to note changes:", error);
            viewerContent.textContent = "Error loading note.";
            multitaskViewer.textContent = "Error loading note.";
          }
        );
      }

      // Cleanup on logout or window close
      async function cleanup() {
        // Stop heartbeat
        if (heartbeatInterval) {
          clearInterval(heartbeatInterval);
          heartbeatInterval = null;
        }

        // Stop history auto-save
        stopHistoryAutoSave();

        // Unsubscribe from listeners
        if (activeDevicesListener) activeDevicesListener();
        if (noteListener) noteListener();
        activeDevicesListener = null;
        noteListener = null;

        // Remove device from Firestore
        if (currentUser && deviceIP) {
          const deviceRef = db
            .collection("users")
            .doc(currentUser.uid)
            .collection("activeDevices")
            .doc(deviceIP);
          await deviceRef
            .delete()
            .catch((err) => console.error("Cleanup error:", err));
        }
      }

      window.addEventListener("beforeunload", (event) => {
        if (auth.currentUser) {
          cleanup();
        }
      });

      // Handle page visibility changes
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          // Page is hidden, stop heartbeat
          if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;
          }
        } else {
          // Page is visible again, restart heartbeat
          if (currentUser && !heartbeatInterval) {
            startHeartbeat();
          }
        }
      });

      // =================================================================
      // ðŸ“š DOCUMENT HISTORY MANAGEMENT
      // =================================================================

      // Load document history from Firestore
      async function loadDocumentHistory() {
        if (!currentUser) return;

        try {
          const historyRef = db
            .collection("users")
            .doc(currentUser.uid)
            .collection("notes")
            .doc(NOTE_ID)
            .collection("history")
            .orderBy("timestamp", "desc")
            .limit(20);

          const snapshot = await historyRef.get();
          documentHistory = snapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          }));

          renderDocumentHistory();
        } catch (error) {
          console.error("Error loading document history:", error);
          historyList.innerHTML =
            '<div class="no-history">Error loading history</div>';
        }
      }

      // Render document history list
      function renderDocumentHistory() {
        if (documentHistory.length === 0) {
          historyList.innerHTML =
            '<div class="no-history">No document history found</div>';
          return;
        }

        historyList.innerHTML = documentHistory
          .map((doc, index) => {
            const date =
              doc.timestamp?.toDate?.() ||
              new Date(doc.timestamp || Date.now());
            const formattedDate = date.toLocaleString();
            const preview = doc.content
              ? doc.content.substring(0, 100) +
                (doc.content.length > 100 ? "..." : "")
              : "No content";

            return `
             <div class="history-item" data-index="${index}">
               <div class="history-info">
                 <div class="history-title">Version ${
                   documentHistory.length - index
                 }</div>
                 <div class="history-meta">
                   <span class="material-icons" style="font-size: 12px;">schedule</span>
                   ${formattedDate}
                   ${doc.updatedBy ? ` â€¢ Updated by ${doc.updatedBy}` : ""}
                 </div>
                 <div style="font-size: 0.8rem; color: #888; margin-top: 5px;">
                   ${preview}
                 </div>
               </div>
               <div class="history-actions">
                 <button class="history-btn" onclick="previewDocument(${index})">
                   <span class="material-icons">visibility</span> View
                 </button>
                 <button class="history-btn" onclick="restoreDocument(${index})">
                   <span class="material-icons">restore</span> Restore
                 </button>
               </div>
             </div>
           `;
          })
          .join("");
      }

      // Preview a document from history
      function previewDocument(index) {
        const doc = documentHistory[index];
        if (!doc) return;

        selectedHistoryDoc = doc;
        previewContent.textContent = doc.content || "No content";
        historyPreview.classList.remove("hidden");

        // Update active state
        document.querySelectorAll(".history-item").forEach((item) => {
          item.classList.remove("active");
        });
        document
          .querySelector(`[data-index="${index}"]`)
          .classList.add("active");
      }

      // Restore a document from history
      async function restoreDocument(index) {
        const doc = documentHistory[index];
        if (!doc || !currentUser) return;

        if (
          confirm(
            "Are you sure you want to restore this version? This will replace the current content."
          )
        ) {
          try {
            // Update current note with restored content
            const noteRef = db
              .collection("users")
              .doc(currentUser.uid)
              .collection("notes")
              .doc(NOTE_ID);

            await noteRef.set({
              content: doc.content,
              updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
              updatedBy: deviceIP,
              restoredFrom: doc.id,
            });

            // Add to history
            await noteRef.collection("history").add({
              content: doc.content,
              timestamp: firebase.firestore.FieldValue.serverTimestamp(),
              updatedBy: deviceIP,
              action: "restored",
            });

            alert("Document restored successfully!");
            loadDocumentHistory(); // Refresh history
            historyPreview.classList.add("hidden");
          } catch (error) {
            console.error("Error restoring document:", error);
            alert("Error restoring document");
          }
        }
      }

      // Save current document to history
      async function saveToHistory(content) {
        if (!currentUser || !content) return;

        try {
          const historyRef = db
            .collection("users")
            .doc(currentUser.uid)
            .collection("notes")
            .doc(NOTE_ID)
            .collection("history");

          await historyRef.add({
            content: content,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            updatedBy: deviceIP,
          });
        } catch (error) {
          console.error("Error saving to history:", error);
        }
      }

      // Event listeners for history
      document
        .getElementById("refresh-history-btn")
        .addEventListener("click", loadDocumentHistory);
      document
        .getElementById("restore-doc-btn")
        .addEventListener("click", () => {
          if (selectedHistoryDoc) {
            const index = documentHistory.findIndex(
              (doc) => doc.id === selectedHistoryDoc.id
            );
            if (index !== -1) {
              restoreDocument(index);
            }
          }
        });

      // Auto-save to history every 5 minutes
      let historySaveInterval = null;

      function startHistoryAutoSave() {
        historySaveInterval = setInterval(() => {
          const currentContent =
            noteEditor.value || multitaskEditor.value || "";
          if (currentContent.trim()) {
            saveToHistory(currentContent);
          }
        }, 300000); // 5 minutes
      }

      function stopHistoryAutoSave() {
        if (historySaveInterval) {
          clearInterval(historySaveInterval);
          historySaveInterval = null;
        }
      }

      // Start auto-save when user logs in
      auth.onAuthStateChanged(async (user) => {
        if (user) {
          // ... existing code ...
          startHistoryAutoSave();
        } else {
          // ... existing code ...
          stopHistoryAutoSave();
        }
      });
    </script>
  </body>
</html>
